### Storing the deployed contracts

In the current `StorageFactory` version, every time `createSimpleStorageContract` is called, a new `SimpleStorage` 
contract is deployed and **overridden** inside the variable `SimpleStorage`. Past deployments are not being tracked down.

To solve this issue we can create a variable `listOfSimpleStorageContracts`, which is an array of `SimpleStorage` contracts. 
In this way, whenever a contract is created, it gets added to a dynamic array.

SimpleStorage[] public listOfSimpleStorageContracts;

function createSimpleStorageContract() public {
    SimpleStorage simpleStorageContractVariable = new SimpleStorage();
    listOfSimpleStorageContracts.push(simpleStorageContractVariable);
}

### Simple Storage interaction

`StorageFactory` can interact with the deployed contracts by calling their `store` function. 
To do this we need to create a function `sfStore`:

function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {
    //SimpleStorage store function will be called here
}

 üëÄ‚ùóIMPORTANT
 Every time you have to interact with another contract, you need:
1. the contract **address**
2. the contract **ABI (Application Binary Interface)**: a standardized way for interacting with the binary version 
of a smart contract deployed on the blockchain. It specifies the functions, their parameters, and the structure of 
the data that can be used to interact with the contract. It's generated by the compiler.

We can now proceed to store a new number on a `SimpleStorage` contract:
function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {
    listOfSimpleStorageContracts[_simpleStorageIndex].store( _simpleStorageNumber);
}

We can then retrieve the stored value with a _get_ function:
function sfGet(uint256 _simpleStorageIndex) public view returns (uint256) {
        // return SimpleStorage(address(simpleStorageArray[_simpleStorageIndex])).retrieve();
        return listOfSimpleStorageContracts[_simpleStorageIndex].retrieve();
    }
